package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.32

import (
	"context"
	"hm2/sessions_stat_service/graph/model"
	"time"
)

// CreateGame is the resolver for the CreateGame field.
func (r *mutationResolver) CreateGame(ctx context.Context, gameInfo model.GameInfo, players []*model.PlayerData) (bool, error) {
	r.Mutex.Lock()
	defer r.Mutex.Unlock()
	id := gameInfo.ID
	_, ok := r.Index[id]
	if ok {
		return false, nil
	}
	currentTime := time.Now()
	dt := currentTime.String()
	players_list := make([]*model.Player, 0)
	for i := 0; i < len(players); i++ {
		p := &model.Player{Username: players[i].Username, Role: players[i].Role, Alive: true}
		players_list = append(players_list, p)
	}
	game_info := model.Game{ID: id, Comments: make([]*model.Comment, 0), Date: dt, State: gameInfo.State, Players: players_list}
	r.Games = append(r.Games, game_info)
	r.Index[id] = len(r.Games) - 1
	return true, nil
}

// UpdateGame is the resolver for the UpdateGame field.
func (r *mutationResolver) UpdateGame(ctx context.Context, gameID string, newState model.GameState, playerStatuses []*model.PlayerStatus) (bool, error) {
	r.Mutex.Lock()
	defer r.Mutex.Unlock()
	id := gameID
	idx, ok := r.Index[id]
	if !ok {
		return false, nil
	}
	g := &r.Games[idx]
	g.State = newState
	mp := make(map[string]bool)
	for i := 0; i < len(playerStatuses); i++ {
		mp[playerStatuses[i].Username] = playerStatuses[i].Alive
	}
	if len(mp) != len(g.Players) {
		return false, nil
	}
	for i := 0; i < len(g.Players); i++ {
		alive, ok := mp[g.Players[i].Username]
		if !ok {
			return false, nil
		}
		g.Players[i].Alive = alive
	}
	return true, nil
}

// AddComment is the resolver for the AddComment field.
func (r *mutationResolver) AddComment(ctx context.Context, gameID string, data model.CommentData) (bool, error) {
	r.Mutex.Lock()
	defer r.Mutex.Unlock()
	id := gameID
	idx, ok := r.Index[id]
	if !ok {
		return false, nil
	}
	g := &r.Games[idx]
	g.Comments = append(g.Comments, &model.Comment{Text: data.Text, Source: data.Source, Date: time.Now().String()})
	return true, nil
}

// GetGamesInfo is the resolver for the GetGamesInfo field.
func (r *queryResolver) GetGamesInfo(ctx context.Context, ids []string) ([]*model.Game, error) {
	r.Mutex.Lock()
	defer r.Mutex.Unlock()
	result := make([]*model.Game, 0)
	for i := 0; i < len(ids); i++ {
		idx, ok := r.Index[ids[i]]
		if ok {
			result = append(result, &r.Games[idx])
		}
	}
	return result, nil
}

// ListGames is the resolver for the ListGames field.
func (r *queryResolver) ListGames(ctx context.Context, maxCount int, state model.GameState) ([]string, error) {
	r.Mutex.Lock()
	defer r.Mutex.Unlock()
	result := make([]string, 0)
	for i := 0; i < len(r.Games); i++ {
		if (len(result) == maxCount) {
			break
		}
		if r.Games[i].State == state {
			result = append(result, r.Games[i].ID)
		}
	}
	return result, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
